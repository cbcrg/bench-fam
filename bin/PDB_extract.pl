#! /usr/bin/perl
# 
# Extract from the PDB files only the parts corresponding to the sequences found in the fasta file
# and generate new PDB files with unique name (in case the same PDB file is used as template)

###################################################################################################
# This script requires as input files : 
# - a template file (PDB associated with a given sequence)
# - a fasta file containing sequences (the fasta file has been generated by extracting 
# sequences for which a PDB has been identified with 95% identity and coverage)
# Thus the template file (keep.list) and the fasta file must have the same number
# of entries and in the same order !!!!
#
# This script will identify within the PDB file the part corresponding to the precise
# sequence in the fasta file and extract it into a new PDB file with a unique name 
# given by the name of the PDB, the chainid and an index corresponding to the number 
# of time this PDB has been encountered in the template file.
###################################################################################################

use strict;
use File::Copy;

open(TMP_INIT,"temp.list");
open(TMP_MODIF,">modified.template");
open(PML_SCRPT,">super.pml");
open(FASTA,"temp.fasta");
open(FASTA_MODIF,">modified.fasta");

# Sliding window of 20 aa when comparing Pfam and PDB sequences
my $sw=5;

# Filter on sequence length (% of the average)
my $sl=0.75;
my $sh=1.50;

# from initial template file
my @tmppdb=();
my @tmpname=();
my @tmpnter=();
my @tmpcter=();

# from fasta file
my @fastaname=();
my @fastaseq=();

# from pdb file
my @pdbseq=();
my @pdbpos=();
my @pdbnter=();
my @pdbcter=();

# temporary arrays
my @tempname;


#############################################################################
# 1st step
# extract pdb information from the template file
#############################################################################
my $ia=0;
while (my $line1=<TMP_INIT>)
{
	$line1=~/>(\w+)\/(\w+)-(\w+)  (\w+) (\w+)/;
	if ($4 eq "_P_")
	{
		$ia++;
		push(@tmpname,"$1");		
		push(@tmppdb,"$5");		
		push(@tmpnter,"$2");
		push(@tmpcter,"$3");
	}
}

#############################################################################
# 2nd step
# determine if repeats or tandem presents and rename pdb with an index number
#############################################################################

#print "$ia number of templates \n";
my $red;
my $red2;
my $count;
my $exit;

for ($red=0;$red<=$ia-2;$red++)
{ 
	$count=1;
	for ($red2=$red+1;$red2<=$ia-1;$red2++)
	{
#		if (@tmpname[$red] ne @tmpname[$red2] && @tmppdb[$red] eq @tmppdb[$red2])
#		{
#			print "Same template for different proteins\n";
#		}
#		if (@tmpname[$red] eq @tmpname[$red2] && @tmppdb[$red] eq @tmppdb[$red2])
		if (@tmppdb[$red] eq @tmppdb[$red2])
		{
		$count++;
		copy ("@tmppdb[$red2].pdb","@tmppdb[$red2]-$count.pdb");
		@tmppdb[$red2]="@tmppdb[$red2]-$count";
		}
	}
	if ($count=1)
	{
		if (substr(@tmppdb[$red],5,1) ne "-")
		{ 
			copy ("@tmppdb[$red].pdb","@tmppdb[$red]-$count.pdb");
			@tmppdb[$red]=@tmppdb[$red]."-$count";
		}
	}
}

if (substr(@tmppdb[$ia-1],5,1) ne "-")
{
	copy ("@tmppdb[$ia-1].pdb","@tmppdb[$ia-1]-1.pdb");
	@tmppdb[$ia-1]=@tmppdb[$ia-1]."-1";
}
#for ($exit=0;$exit<=$ia-1;$exit++)
#{
#	print TMP_MODIF ">@tmpname[$exit]/@tmpnter[$exit]-@tmpcter[$exit] _P_ @tmppdb[$exit]\n";
#}

#############################################################################
# 3rd step 
# extract seq information from fasta file
#############################################################################
my $ib;
my $seq;

while (my $line2=<FASTA>)
{
	my $char=substr($line2,0,1);
	if ($char eq '>')
	{
		$ib++;
		$line2=~/>(\w+)\/(\w+)-(\w+)/;
		push(@fastaname,"$1/$2-$3");
		if ($ib>1)
		{
			push(@fastaseq,"$seq");
			$seq="";
		}
	}
	if ($char ne'>')
	{
		chomp($line2);
		$seq=$seq.$line2;
	}
}

	push(@fastaseq,$seq);

#my $itest;
#for ($itest=0;$itest<=$ia-1;$itest++)
#{
#print @fastaseq[$itest],"\n";
#}

#############################################################################
# 3bis step
# Verification sequences (in fasta) = sequences (in template)
#############################################################################
my $ic;
for ($ic=0;$ic<=$ia-1;$ic++)
{
	@tempname[$ic]="@tmpname[$ic]/@tmpnter[$ic]-@tmpcter[$ic]";
	if (@tempname[$ic]ne@fastaname[$ic]) {die ("Template and Fasta files do not contains the domains in the same order");}
}

############################################################################
# 3rd ter step
# Calculate the average lenght of all sequences within the dataset
#############################################################################
my $ie;
my $sum=0;
my $avr=0;
for ($ie=0;$ie<=$ia-1;$ie++)
{
	print length(@fastaseq[$ie])," protein @fastaname[$ie] \n";
        $sum=$sum+length(@fastaseq[$ie]);
}
$avr=$sum/($ia);
print "Average length for dataset is $avr \n";


#############################################################################
# 4th step
# extract fasta sequence information from the pdb file
#############################################################################
my $ipdb;
my $rtyp_1;
my $pdb_seq;
my $pdb_pos;
my @fm;

for ($ipdb=0;$ipdb<=$ia-1;$ipdb++)
{
	open (PDB_FILE,"@tmppdb[$ipdb].pdb");
#	print @tmppdb[$ipdb],"\n";
	while (my $line3=<PDB_FILE>)
	{
                @fm=split("",$line3);
		my $field = ("@fm[0]"."@fm[1]"."@fm[2]"."@fm[3]"."@fm[4]"."@fm[5]");
		my $pos = ("@fm[6]"."@fm[7]"."@fm[8]"."@fm[9]"."@fm[10]");
		my $atyp = ("@fm[12]"."@fm[13]"."@fm[14]"."@fm[15]");
		my $rtyp = ("@fm[17]"."@fm[18]"."@fm[19]");
		my $chid = ("@fm[21]");
		my $resid = ("@fm[22]"."@fm[23]"."@fm[24]"."@fm[25]");

		if ($field eq 'ATOM  ' && $atyp eq ' CA ')
		{
			if ($rtyp eq 'ALA') {$rtyp_1="A";}
			elsif ($rtyp eq 'ARG') {$rtyp_1="R";}
			elsif ($rtyp eq 'ASN') {$rtyp_1="N";}
			elsif ($rtyp eq 'ASP') {$rtyp_1="D";}
			elsif ($rtyp eq 'CYS') {$rtyp_1="C";}
			elsif ($rtyp eq 'GLN') {$rtyp_1="Q";}
			elsif ($rtyp eq 'GLU') {$rtyp_1="E";}
			elsif ($rtyp eq 'GLY') {$rtyp_1="G";}
			elsif ($rtyp eq 'HIS') {$rtyp_1="H";}
			elsif ($rtyp eq 'ILE') {$rtyp_1="I";}
			elsif ($rtyp eq 'LEU') {$rtyp_1="L";}
			elsif ($rtyp eq 'LYS') {$rtyp_1="K";}
			elsif ($rtyp eq 'MET') {$rtyp_1="M";}
			elsif ($rtyp eq 'PHE') {$rtyp_1="F";}
			elsif ($rtyp eq 'PRO') {$rtyp_1="P";}
			elsif ($rtyp eq 'SER') {$rtyp_1="S";}
			elsif ($rtyp eq 'THR') {$rtyp_1="T";}
			elsif ($rtyp eq 'TRP') {$rtyp_1="W";}
			elsif ($rtyp eq 'TYR') {$rtyp_1="Y";}
			elsif ($rtyp eq 'VAL') {$rtyp_1="V";}
			else  {print "STDERR : Unkown aminoacid in sequence\n";}
			$pdb_seq=$pdb_seq.$rtyp_1;
			$pdb_pos="$pdb_pos $resid";
		}
	}
		push (@pdbseq,"$pdb_seq");
		push (@pdbpos,"$pdb_pos");
		$pdb_seq="";
		$pdb_pos="";
}

#my $itest;
#for ($itest=0;$itest<=$ia-1;$itest++)
#{
#print @pdbseq[$itest],"\n";
#}

############################################################################
# 5th step
# Find the part of the PDB sequence corresponding to the Pfam sequence 
#############################################################################

my $id;
my $ik;
my $il;
my $im;
my $gap;
my $nogap;
my $nores;
my $noseq;
my $boundary1;
my $boundary2;

for ($ik=0;$ik<=$ia-1;$ik++) 
	{ 
		$nogap=0;
		$noseq=0;
		for ($gap=0;$gap<=int(0.05*length(@fastaseq[$ik]));$gap++)
# Test on the coverage of the sequences : number of residues in Nter that could be missing !!!
		{
#		if (length(@fastaseq[$ik])>=20) {$sw=20;}
#		if (length(@fastaseq[$ik])<20) {$sw=10;}
		if (length(@fastaseq[$ik])<10) { print "STDERR : Sequence length is too short\n"; }
#		print "Sliding window size : $sw\n";
			if ($nogap<1)
			{
			        my $window1=substr(@fastaseq[$ik],$gap,$sw);
#				print "WINDOW1 : $window1\n";
				for ($il=0;$il<=length(@pdbseq[$ik])-$sw;$il++)
				{
					my $window2=substr(@pdbseq[$ik],$il,$sw);
#					print "WINDOW2 : $window2\n";
					$id=0;
					for ($im=0;$im<=$sw-1;$im++)
					{
						if (substr($window1,$im,1) eq substr($window2,$im,1))
						{
							$id++;
						}
					}
# Test on the identity of the sliding window : number of differences tolerated !!
					if ($id>=int(0.90*$sw))
					{
						$noseq++;
						$nogap++;
						$nores=$il-@pdbpos[$ik];
						$boundary1=@pdbpos[$ik]+$il;
						$boundary2=length(@fastaseq[$ik])+$boundary1-1;
				
					}
				}
			}
		}
# If no match is found between sliding window 1 and 2 (seq from Pfam and seq from PDB) then STDERR
# Then the sequence is removed from the fasta file and from the template file !!! 
		if ($noseq<1)
		{
			print "STDERR : For @tmppdb[$ik], difference between Pfam and PDB sequences\n";
		}
		if ($noseq>0)
		{
# Filtering on the length of the sequences if too short (cut) or too long (extra)
			if ( (length(@fastaseq[$ik])>$sl*int($avr)) && (length(@fastaseq[$ik])<$sh*int($avr)))
			{
				print TMP_MODIF ">@tmpname[$ik]/@tmpnter[$ik]-@tmpcter[$ik] _P_ @tmppdb[$ik]\n";
				print FASTA_MODIF ">@tmpname[$ik]/@tmpnter[$ik]-@tmpcter[$ik]\n";
				print FASTA_MODIF "@fastaseq[$ik]\n";
			}
			if (length(@fastaseq[$ik])<($sl*int($avr)))
			{
				print "STDERR : For @tmppdb[$ik], sequence is too short\n";
			}
			if (length(@fastaseq[$ik])>($sh*int($avr)))
			{
				print "STDERR : For @tmppdb[$ik], sequence is too long\n";
			}
		}
		open (PDB_FILE,"@tmppdb[$ik].pdb");
		my $pdb_temp="@tmppdb[$ik]_cut.pdb";
		open (PDB_TEMP,">$pdb_temp");
		my $iseq=0;
		my $ires=0;
		my @fm2;
	        while (my $line4=<PDB_FILE>)
      		{
                my @fm2=split("",$line4);
                my $field2 = ("@fm2[0]"."@fm2[1]"."@fm2[2]"."@fm2[3]"."@fm2[4]"."@fm2[5]");
                my $pos2 = ("@fm2[6]"."@fm2[7]"."@fm2[8]"."@fm2[9]"."@fm2[10]");
                my $atyp2 = ("@fm2[12]"."@fm2[13]"."@fm2[14]"."@fm2[15]");
                my $rtyp2 = ("@fm2[17]"."@fm2[18]"."@fm2[19]");
                my $chid2 = ("@fm2[21]");
                my $resid2 = ("@fm2[22]"."@fm2[23]"."@fm2[24]"."@fm2[25]");
			if ($field2 eq 'SEQRES') 
			{
# The number 13 corresponds to the number of residues in one line of the SEQRES field
# Only the SEQRES line corresponding to the sequence are kept
				$iseq++;
				$ires=$iseq*13;
				if ($ires>=$nores) { print PDB_TEMP $line4; }
			}
# Select the PDB part corresponding to the PFAM sequences using the boundaries resid
                	if ($field2 ne 'ATOM  ' && $field2 ne 'SEQRES') { print PDB_TEMP $line4; }
			if ($field2 eq 'ATOM  ' && $resid2>=$boundary1 && $resid2<=$boundary2) { print PDB_TEMP $line4; }
		}
		close (PDB_FILE);
		close (PDB_TEMP);
		move ("@tmppdb[$ik]_cut.pdb","@tmppdb[$ik].pdb");
	}

#############################################################################
# 6th step
# write the pymol script containing load, superimpose and formatting
#############################################################################
my $in;

for ($in=0;$in<=$ia-1;$in++)
{ 
	my $loadline="load  @tmppdb[$in].pdb , @tmppdb[$in]\n";
	print PML_SCRPT $loadline; 
}

for ($in=0;$in<=$ia-1;$in++)
{ 
	my $superline="super @tmppdb[$in] ,  @tmppdb[$1]\n";
	print PML_SCRPT $superline; 
}

print PML_SCRPT "hide \n";
print PML_SCRPT "show ribbon \n";

#############################################################################
# 7th step
# close all opened files
#############################################################################
close(TMP_INIT); 
close(TMP_MODIF); 
close(PML_SCRPT); 
close(FASTA); 
close (FASTA_MODIF);
close(PDB_FILE);
