#! /usr/bin/perl
# 
####################################################################################################
# OBJECTIVE OF THE SCRIPT 
# Extract from the PDB files only the parts corresponding to the sequences found in the fasta file
# and generate new PDB files with unique name (in case the same PDB file is used as template)
# 
####################################################################################################
# REQUIREMENTS AND EXPLANATION
# This script requires as input files : 
# ARG1 - a fasta file containing sequences (the fasta file has been generated by extracting 
# ARG2 - a template file (PDB associated with a given sequence)
#
# This script will identify within the PDB file the part corresponding to the precise
# sequence in the fasta file and extract it into a new PDB file with a unique name 
# given by the name of the PDB, the chainid and an index corresponding to the number 
# of time this PDB has been encountered in the template file.
#
####################################################################################################

use strict;
use File::Copy;

# files
my $file1 = $ARGV[0];
my $file2 = $ARGV[1];
my $sw=$ARGV[2];
my $sl=$ARGV[3];
my $sh=$ARGV[4];
my $cov=$ARGV[5];
my $idt=$ARGV[6];

print "FASTA - TEMPLATE / FILTERS : WINDOW SIZE - LENGTH MIN - LENGTH MAX - GAPS MAX - ID MIN\n";

# Parameters for filtering (% of avrg length, % identity, % coverage and sliding window)
#my $sw=5;
#my $sl=0.75;
#my $sh=1.50;
#my $cov=0.05;
#my $idt=0.90;

# from initial template file
my @tmppdb=();
my @tmpname=();
my @tmpnter=();
my @tmpcter=();

# from fasta file
my @fastaname=();
my @fastaseq=();

# from pdb file
my @pdbseq=();
my @pdbpos=();

# temporary arrays
my @tempname;


####################################################################################################
# Preliminary step
# create from expresso results a new fasta (sequences with 3D only)
####################################################################################################

open(FASTA,"$file1");
open(FASTA_MODIF,">modified.fasta");
open(TEMPL,"$file2");
open(TEMPL_EXTRA,">temp.list");
open(TEMPL_MODIF,">modified.template");
open(PML_SCRP,">super.pml");

####################################################################################################
# 1st step
# extract pdb information from the template file
####################################################################################################
my $ia=0;
while (my $line1=<TEMPL>)
{
	$line1=~/>(\w+)\/(\w+)-(\w+)(\s+)(\w+)(\s+)(\w+)/;
	if ($5 eq "_P_")
	{
		print TEMPL_EXTRA "$line1";
		$ia++;
		push(@tmpname,"$1");		
		push(@tmppdb,"$7");		
		push(@tmpnter,"$2");
		push(@tmpcter,"$3");
	}
}

`t_coffee -other_pg seq_reformat -in $file1 -action +extract_seq_list temp.list > temp.fa`;
open(FASTA_EXTRA,"temp.fa");
####################################################################################################
# 2nd step
# determine if repeats or tandem presents and rename pdb with an index number
####################################################################################################

my $red;
my $red2;
my $count;
my $exit;

for ($red=0;$red<=$ia-2;$red++)
{ 
	$count=1;
	for ($red2=$red+1;$red2<=$ia-1;$red2++)
	{
#		if (@tmpname[$red] ne @tmpname[$red2] && @tmppdb[$red] eq @tmppdb[$red2])
#		{
#			print "Same template for different proteins\n";
#		}
#		if (@tmpname[$red] eq @tmpname[$red2] && @tmppdb[$red] eq @tmppdb[$red2])
		if (@tmppdb[$red] eq @tmppdb[$red2])
		{
		$count++;
		copy ("$tmppdb[$red2].pdb","$tmppdb[$red2]-$count.pdb");
		$tmppdb[$red2]="$tmppdb[$red2]-$count";
		}
	}
	if ($count=1)
	{
		if (substr($tmppdb[$red],5,1) ne "-")
		{ 
			copy ("$tmppdb[$red].pdb","$tmppdb[$red]-$count.pdb");
			$tmppdb[$red]=$tmppdb[$red]."-$count";
		}
	}
}

if (substr($tmppdb[$ia-1],5,1) ne "-")
{
	copy ("$tmppdb[$ia-1].pdb","$tmppdb[$ia-1]-1.pdb");
	$tmppdb[$ia-1]=$tmppdb[$ia-1]."-1";
}

####################################################################################################
# 3rd step 
# extract seq information from fasta file
####################################################################################################
my $ib;
my $seq;

while (my $line2=<FASTA_EXTRA>)
{
	my $char=substr($line2,0,1);
	if ($char eq '>')
	{
		$ib++;
		$line2=~/>(\w+)\/(\w+)-(\w+)/;
		push(@fastaname,"$1/$2-$3");
		if ($ib>1)
		{
			push(@fastaseq,"$seq");
			$seq="";
		}
	}
	if ($char ne'>')
	{
		chomp($line2);
		$seq=$seq.$line2;
	}
}

push(@fastaseq,$seq);

#my $itest;
#for ($itest=0;$itest<=$ia-1;$itest++)
#{
#print $fastaseq[$itest],"\n";
#}

####################################################################################################
# 3bis step
# Verification sequences (in fasta) = sequences (in template)
####################################################################################################
my $ic0;
my $ic1;
my $ic2;

for ($ic0=0;$ic0<=$ia-1;$ic0++)
{
	$tempname[$ic0]="$tmpname[$ic0]/$tmpnter[$ic0]-$tmpcter[$ic0]";
	for ($ic1=0;$ic1<=$ia-1;$ic1++)
	{
		if ($tempname[$ic0] eq $fastaname[$ic1]) { $ic2++;}
	}
#{die ("Template and Fasta files do not contains the domains in the same order");}
}
if ($ic2 ne $ia) {die ("Not the same name and number of sequences between fasta and template");}

####################################################################################################
# 3rd ter step
# Calculate the average length of all sequences within the dataset
####################################################################################################
my $ie;
my $sum=0;
my $avr=0;
for ($ie=0;$ie<=$ia-1;$ie++)
{
	print length($fastaseq[$ie])," protein $fastaname[$ie] \n";
	$sum=$sum+length($fastaseq[$ie]);
}
$avr=$sum/($ia);
print "Average length for dataset is $avr \n";


####################################################################################################
# 4th step
# extract fasta sequence information from the pdb file
####################################################################################################
my $ipdb;
my $rtyp_1;
my $pdb_seq;
my $pdb_pos;

for ($ipdb=0;$ipdb<=$ia-1;$ipdb++)
{
	open (PDB_FILE,"$tmppdb[$ipdb].pdb");
	while (my $line3=<PDB_FILE>)
	{

		$line3=~/(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)/;
		if ($1 eq 'ATOM' && $5 eq 'CA')
		{
			if ($7 eq 'ALA') {$rtyp_1="A";}
			elsif ($7 eq 'ARG') {$rtyp_1="R";}
			elsif ($7 eq 'ASN') {$rtyp_1="N";}
			elsif ($7 eq 'ASP') {$rtyp_1="D";}
			elsif ($7 eq 'CYS') {$rtyp_1="C";}
			elsif ($7 eq 'GLN') {$rtyp_1="Q";}
			elsif ($7 eq 'GLU') {$rtyp_1="E";}
			elsif ($7 eq 'GLY') {$rtyp_1="G";}
			elsif ($7 eq 'HIS') {$rtyp_1="H";}
			elsif ($7 eq 'ILE') {$rtyp_1="I";}
			elsif ($7 eq 'LEU') {$rtyp_1="L";}
			elsif ($7 eq 'LYS') {$rtyp_1="K";}
			elsif ($7 eq 'MET') {$rtyp_1="M";}
			elsif ($7 eq 'PHE') {$rtyp_1="F";}
			elsif ($7 eq 'PRO') {$rtyp_1="P";}
			elsif ($7 eq 'SER') {$rtyp_1="S";}
			elsif ($7 eq 'THR') {$rtyp_1="T";}
			elsif ($7 eq 'TRP') {$rtyp_1="W";}
			elsif ($7 eq 'TYR') {$rtyp_1="Y";}
			elsif ($7 eq 'VAL') {$rtyp_1="V";}
			else { print "STDERR : Unkown aminoacid in sequence\n";}
			$pdb_seq=$pdb_seq.$rtyp_1;
			$pdb_pos="$pdb_pos $11";
		}
	}
		push (@pdbseq,"$pdb_seq");
		push (@pdbpos,"$pdb_pos");
		$pdb_seq="";
		$pdb_pos="";
}

####################################################################################################
# 5th step
# Find the part of the PDB sequence corresponding to the Pfam sequence 
####################################################################################################
my $id;
my $ik;
my $il;
my $im;
my $gap;
my $nogap;
my $nores;
my $noseq;
my $boundary1;
my $boundary2;

for ($ik=0;$ik<=$ia-1;$ik++) 
	{ 
		$nogap=0;
		$noseq=0;
		for ($gap=0;$gap<=int($cov*length($fastaseq[$ik]));$gap++)
# Test on the coverage of the sequences : number of residues in Nter that could be missing !!!
		{
		if (length($fastaseq[$ik])<10) { print "STDERR : Sequence length is too short\n"; }
			if ($nogap<1)
			{
				my $window1=substr($fastaseq[$ik],$gap,$sw);
#				print "WINDOW1 : $window1\n";
				for ($il=0;$il<=length($pdbseq[$ik])-$sw;$il++)
				{
					my $window2=substr($pdbseq[$ik],$il,$sw);
#					print "WINDOW2 : $window2\n";
					$id=0;
					for ($im=0;$im<=$sw-1;$im++)
					{
						if (substr($window1,$im,1) eq substr($window2,$im,1))
						{
							$id++;
						}
					}
# Test on the identity of the sliding window : number of differences tolerated !!
					my $test=($idt*$sw);
					if ($id>=($idt*$sw))
					{
#						print " $window2 $id GOOD HIT >90% identity\n";
						$noseq++;
						$nogap++;
						$nores=$il-$pdbpos[$ik];
						$boundary1=$pdbpos[$ik]+$il;
#						print "FIRST LIMIT $boundary1 \n";
						$boundary2=length($fastaseq[$ik])+$boundary1-1;
#						print "FINAL LIMIT $boundary2 \n";
				
					}
				}
			}
		}
# If no match is found between sliding window 1 and 2 (seq from Pfam and seq from PDB) then STDERR
# Then the sequence is removed from the fasta file and from the template file !!! 
		if ($noseq<1)
		{
			print "STDERR : For $tmppdb[$ik], difference between Pfam and PDB sequences\n";
		}
		if ($noseq>0)
		{
# Filtering on the length of the sequences if too short (cut) or too long (extra)
			if ( (length($fastaseq[$ik])>$sl*int($avr)) && (length($fastaseq[$ik])<$sh*int($avr)))
			{
				print TEMPL_MODIF ">$tmpname[$ik]/$tmpnter[$ik]-$tmpcter[$ik] _P_ $tmppdb[$ik]\n";
				print FASTA_MODIF ">$tmpname[$ik]/$tmpnter[$ik]-$tmpcter[$ik]\n";
#				print "$fastaseq[$ik]\n";
				$fastaseq[$ik]=~tr/U/X/;
#				print "$fastaseq[$ik]\n";
				print FASTA_MODIF "$fastaseq[$ik]\n";
			}
			if (length($fastaseq[$ik])<=($sl*int($avr)))
			{
				print "STDERR : For $tmppdb[$ik], sequence is too short\n";
			}
			if (length($fastaseq[$ik])>($sh*int($avr)))
			{
				print "STDERR : For $tmppdb[$ik], sequence is too long\n";
			}
		}
		open (PDB_FILE,"$tmppdb[$ik].pdb");
		my $pdb_temp="$tmppdb[$ik]_cut.pdb";
		open (PDB_TEMP,">$pdb_temp");
		my $iseq=0;
		my $ires=0;
		while (my $line4=<PDB_FILE>)
		{
			$line4=~/(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)(\w+)(\s+)/;
			if ($1 eq 'SEQRES') 
			{
# The number 13 corresponds to the number of residues in one line of the SEQRES field
# Only the SEQRES line corresponding to the sequence are kept
				$iseq++;
				$ires=$iseq*13;
				if ($ires>=$nores) { print PDB_TEMP $line4; }
			}
# Select the PDB part corresponding to the PFAM sequences using the boundaries resid
			if ($1 ne 'ATOM' && $1 ne 'SEQRES') { print PDB_TEMP $line4; }
#			print "$pdb_temp... $1 $3 $5 $7 $9 $11\n";
#			print "FIRST : $boundary1 / LAST : $boundary2 \n";
			if ($1 eq 'ATOM' && $11>=$boundary1 && $11<=$boundary2) { print PDB_TEMP $line4; }
		}
		close (PDB_FILE);
		close (PDB_TEMP);
		move ("$tmppdb[$ik]_cut.pdb","$tmppdb[$ik].pdb");
	}

####################################################################################################
# 6th step
# write the pymol script containing load, superimpose and formatting
####################################################################################################
my $in;

for ($in=0;$in<=$ia-1;$in++)
{ 
	my $loadline="load  $tmppdb[$in].pdb , $tmppdb[$in]\n";
	print PML_SCRP $loadline; 
}

for ($in=0;$in<=$ia-1;$in++)
{ 
	my $superline="super $tmppdb[$in] ,  $tmppdb[$1]\n";
	print PML_SCRP $superline; 
}

print PML_SCRP "hide \n";
print PML_SCRP "show ribbon \n";

####################################################################################################
# 7th step
# close all opened files
####################################################################################################
close(TEMPL); 
close(TEMPL_EXTRA); 
close(TEMPL_MODIF); 
close(FASTA); 
close(FASTA_EXTRA);
close(FASTA_MODIF);
close(PDB_FILE);
close(PML_SCRP); 
